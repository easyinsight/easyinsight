<?xml version="1.0" ?>
<mx:Module xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:ilog="ilog.maps.*"
           xmlns:maps="com.easyinsight.analysis.maps.*"
           width="100%" height="100%"
           xmlns:analysis="com.easyinsight.analysis.*" xmlns:map="com.easyinsight.map.*"
           implements="com.easyinsight.analysis.IReportRenderer" creationComplete="blah()"
        removedFromStage="cleanup()">
    <mx:Script>
		<![CDATA[

        import com.easyinsight.analysis.AnalysisItem;
        import com.easyinsight.analysis.CustomChangeEvent;
        import com.easyinsight.analysis.conditions.MeasureCondition;
        import com.easyinsight.analysis.conditions.MeasureConditionRange;
        import com.easyinsight.analysis.conditions.StatefulConditionRenderer;
        import com.easyinsight.filtering.FilterRawData;

        import com.easyinsight.pseudocontext.PseudoContextWindow;

        import ilog.maps.MapBase;

        import com.easyinsight.analysis.conditions.ConditionRenderer;

        import ilog.maps.MapEvent;
        import ilog.maps.MapFeature;

        import com.easyinsight.map.util.MapLocationLookup;

        import com.easyinsight.analysis.AnalysisDefinition;

        import mx.collections.ArrayCollection;
        import mx.controls.Alert;
        import mx.controls.ToolTip;
        import mx.formatters.Formatter;
        import mx.graphics.SolidColor;
        import mx.managers.PopUpManager;
        import mx.managers.ToolTipManager;

        [Bindable]
        private var tooltipFeature:String = "";

        private function blah():void {
            tooltip = ToolTipManager.createToolTip("", 0, 0, null) as ToolTip;
            tooltip.visible = false;
        }

        private function onMouseOut(event:MouseEvent):void {
            tooltip.visible = false;
        }

        public function cleanup():void {
            if (tooltip != null) {
                ToolTipManager.destroyToolTip(tooltip);
            }
        }

        private var tooltip:ToolTip;

        public function onover(event:MapEvent):void {
            if (event.mapFeature != null) {
                var mf:MapFeature = event.mapFeature;
                if (mf != null && mf.data != null) {
                    tooltipFeature += mf.key;
                    var point:Point = mf.mapBarycenter;
                    var canvasPoint:Point = map.drawingCanvas.localToGlobal(point);
                    tooltip.text = mf.data.label + " - " + mf.data.data;
                    tooltip.x = canvasPoint.x;
                    tooltip.y = canvasPoint.y;
                    tooltip.visible = true;
                }
            }
        }

        public function onout(event:MapEvent):void {
            tooltip.visible = false;
        }

        protected function onClick(event:MouseEvent):void {
            if (dimension != null && event.shiftKey) {
                var feature:MapFeature = map.getFeatureAt(event.localX, event.localY);
                if (feature != null) {
                    var obj:Object = new Object();
                    obj[dimension.qualifiedName()] = feature.data.label;
                    window.data = obj;
                    var window:PseudoContextWindow = new PseudoContextWindow(dimension, passThrough, this, mapDefinition, obj);
                    PopUpManager.addPopUp(window, this);
                    window.x = event.stageX + 5;
                    window.y = event.stageY + 5;
                }
            }
        }

        protected function createMap():MapBase {
            return null;
        }

        private function passThrough(event:Event):void {
            dispatchEvent(event);
        }

        [Bindable]
        private var graphData:ArrayCollection = new ArrayCollection();

        private var masterDataSet:ArrayCollection = new ArrayCollection();

        private var map:MapBase;


        private var hasDropAreas:Boolean = true;

        private var dimension:AnalysisItem;

        [Bindable]
        private var conditionRenderer:ConditionRenderer;

        [Bindable]
        private var minValue:Number;

        [Bindable]
        private var maxValue:Number;

        [Bindable]
        private var formatter:Formatter;

        private function createRenderer(rows:ArrayCollection, mapDefinition:MapDefinition):ConditionRenderer {

            var measureRange:MeasureConditionRange = new MeasureConditionRange();
            measureRange.condition = new MeasureCondition();
            measureRange.condition.highColor = mapDefinition.highColor;
            measureRange.condition.highValue = 100;
            measureRange.condition.lowColor = mapDefinition.lowColor;
            measureRange.condition.lowValue = 0;
            if (mapDefinition.colorStrategy == "Linear") {
                measureRange.valueRangeType = MeasureConditionRange.PERCENTAGE;
            } else if (mapDefinition.colorStrategy == "Logarithmic") {
                measureRange.valueRangeType = MeasureConditionRange.LOGARITHM;
            }
            var renderer:StatefulConditionRenderer = new StatefulConditionRenderer(measureRange);
            for (var i:int = 0; i < rows.length; i++) {
                var row:Object = rows.getItemAt(i);
                var dimensionValue:String;
                var measureValue:Object;
                dimensionValue = row[mapDefinition.geography.qualifiedName()];
                measureValue = row[mapDefinition.measure.qualifiedName()];
                var location:String = MapLocationLookup.instance().getLocation(dimensionValue, String(mapType));
                if (location != null) {
                    renderer.addValue(measureValue);
                }
            }
            return renderer;
        }

        private var mapDefinition:MapDefinition;

        public function renderReport(dataSet:ArrayCollection, analysisDefinition:AnalysisDefinition, clientProcessorMap:Object, additionalProperties:Object):void {
            mapDefinition = analysisDefinition as MapDefinition;
            mapDefinition.mapType = mapType;
            dimension = mapDefinition.geography;
            graphData = new ArrayCollection();
            if (dataSet.length > 0) {
                this.formatter = mapDefinition.measure.getFormatter();
                var renderer:ConditionRenderer = createRenderer(dataSet, mapDefinition);
                this.conditionRenderer = renderer;
                this.minValue = Number.MAX_VALUE;
                this.maxValue = Number.MIN_VALUE;
                var matchedLocations:ArrayCollection = new ArrayCollection();
                for (var i:int = 0; i < dataSet.length; i++) {
                    var row:Object = dataSet.getItemAt(i);
                    var dimensionValue:String = row[mapDefinition.geography.qualifiedName()];
                    var measureValue:Number = Number(row[mapDefinition.measure.qualifiedName()]);
                    var testMinValue:Number = Math.min(this.minValue, measureValue);
                    if (!isNaN(testMinValue) && isFinite(testMinValue)) {
                        this.minValue = testMinValue;
                    }
                    var testMaxValue:Number = Math.max(this.maxValue, measureValue);
                    if (!isNaN(testMaxValue) && isFinite(testMaxValue)) {
                        this.maxValue = testMaxValue;
                    }
                    var location:String = MapLocationLookup.instance().getLocation(dimensionValue, String(mapType));
                    if (location != null) {
                        matchedLocations.addItem(location);
                        var mapFeature:MapFeature = map.getFeature(location);
                        if (mapFeature != null) {
                            var dataObj:Object = new Object();
                            dataObj.label = dimensionValue;
                            dataObj.data = mapDefinition.measure.getFormatter().format(measureValue);
                            var color:uint = renderer.getColor(measureValue);
                            mapFeature.data = dataObj;
                            var solidFill:SolidColor = new SolidColor(color);
                            mapFeature.setStyle(MapBase.FILL, solidFill);
                        }
                    }
                }
                var allLocations:Object = MapLocationLookup.instance().getAllLocations(String(mapType));
                for each (var testLocation:String in allLocations) {
                    if (matchedLocations.getItemIndex(testLocation) == -1) {
                        var resetFeature:MapFeature = map.getFeature(testLocation);
                        if (resetFeature != null) {
                            var solidWhite:SolidColor = new SolidColor(0xFFFFFF);
                            resetFeature.setStyle(MapBase.FILL, solidWhite);
                        }
                    }
                }
                if (minValue != Number.MAX_VALUE && maxValue != Number.MIN_VALUE) {
                    legend.recreate();
                }
            }
        }

        protected function get mapType():int {
            return 0;
        }

        public function createFilterRawData():FilterRawData {
            return null;
        }

        public function updateExportMetadata():void {
        }

        public function onCustomChangeEvent(event:CustomChangeEvent):void {
        }

        override protected function createChildren():void {
            super.createChildren();
            map = createMap();
            coreCanvas.addChild(map);
        }

        public function preserveValues():Boolean {
            return false;
        }

		]]>
    </mx:Script>
    <mx:HBox id="chartVBox" width="100%" height="100%">
        <mx:Canvas id="coreCanvas" width="100%" height="100%">

        </mx:Canvas>
        <maps:ColorRangeLegend points="5" conditionRenderer="{conditionRenderer}" maxValue="{maxValue}" minValue="{minValue}"
                formatter="{formatter}" id="legend"/>
        
    </mx:HBox>
</mx:Module>