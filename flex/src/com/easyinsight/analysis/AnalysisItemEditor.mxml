<?xml version="1.0" encoding="utf-8"?>
<mx:Box xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" 
	xmlns:analysis="com.easyinsight.analysis.*"
	creationComplete="initStuff()" creationPolicy="all" xmlns:formatter="com.easyinsight.analysis.formatter.*">
	<mx:states>
		
		<mx:State name="Measure">			
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<analysis:ColorSelection id="measureRangeSelection"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Formatting: ">								
					<formatter:FormattingSetup id="formattingSetup"/>
				</mx:FormItem>
			</mx:AddChild>
		</mx:State>
		
		<mx:State name="ComplexMeasure">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Wrapped Aggregation: ">
					<mx:ComboBox dataProvider="{measureObjects}" id="complexWrappedAggregations"/>
				</mx:FormItem>
			</mx:AddChild>	
		</mx:State>
		
		<mx:State name="TemporalMeasure">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Wrapped Aggregation: ">
					<mx:ComboBox dataProvider="{measureObjects}" id="temporalWrappedAggregations"/>
				</mx:FormItem>
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date Level:" direction="horizontal" enabled="{dimensionIsDate}">
					<mx:ComboBox id="temporalDateBox">
						<mx:ArrayCollection>
							<mx:Object label="Year" data="{AnalysisItemTypes.YEAR_LEVEL}"/>
							<mx:Object label="Month - Year" data="{AnalysisItemTypes.MONTH_LEVEL}"/>
							<mx:Object label="Day - Month - Year" data="{AnalysisItemTypes.DAY_LEVEL}"/>							
						</mx:ArrayCollection>
					</mx:ComboBox>
				</mx:FormItem>
			</mx:AddChild>	
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Grouping: ">
					<mx:ComboBox dataProvider="{dimensionFields}" id="dimensionComboBox" labelField="display" change="onDimensionChange()"/>
				</mx:FormItem>				
			</mx:AddChild>				
		</mx:State>
		
		<mx:State name="Calculation">
			<mx:RemoveChild target="{aggregationBox}"/>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<analysis:ColorSelection id="calcMeasureRangeSelection"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Formatting: ">								
					<formatter:FormattingSetup id="calcFormattingSetup"/>
				</mx:FormItem>
			</mx:AddChild>
		</mx:State>
	
		<mx:State name="Grouping">
            <mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
                <mx:FormItem label="Grouping: " visible="{useKeyDimensionSelected}">
					<mx:ComboBox dataProvider="{dimensionFields}" id="dimensionKeyComboBox" labelField="display"/>
				</mx:FormItem>
            </mx:AddChild>
            <mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
                <mx:CheckBox label="Use Another Grouping as Key: " id="useKeyDimension" selected="{useKeyDimensionSelected}" click="useKeyDimensionSelected = useKeyDimension.selected"/>
            </mx:AddChild>
            <mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
                <mx:FormItem label="Group: ">
                    <mx:CheckBox id="groupCheckbox"/>
                </mx:FormItem>
            </mx:AddChild>
		</mx:State>
		<mx:State name="Range">
			
		</mx:State>
		<mx:State name="List">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Expanded:" direction="horizontal">
					<mx:CheckBox id="listExpanded"/>
				</mx:FormItem>
			</mx:AddChild>
		</mx:State>
		<mx:State name="Date">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date Level:" direction="horizontal">
					<mx:ComboBox id="dateBox" rowCount="10">
						<mx:ArrayCollection>
							<mx:Object label="Year" data="{AnalysisItemTypes.YEAR_LEVEL}"/>
							<mx:Object label="Month - Year" data="{AnalysisItemTypes.MONTH_LEVEL}"/>
							<mx:Object label="Day - Month - Year" data="{AnalysisItemTypes.DAY_LEVEL}"/>							
							<mx:Object label="Day - Month - Year - Hour" data="{AnalysisItemTypes.HOUR_LEVEL}"/>
							<mx:Object label="Day - Month - Year - Hour - Minute" data="{AnalysisItemTypes.MINUTE_LEVEL}"/>

                            <mx:Object label="Week - Year" data="{AnalysisItemTypes.WEEK_LEVEL}"/>
							<mx:Object label="Month" data="{AnalysisItemTypes.MONTH_FLAT}"/>
							<mx:Object label="Day of Year" data="{AnalysisItemTypes.DAY_OF_YEAR_FLAT}"/>
							<mx:Object label="Day of Week" data="{AnalysisItemTypes.DAY_OF_WEEK_FLAT}"/>
							<mx:Object label="Week of Year" data="{AnalysisItemTypes.WEEK_OF_YEAR_FLAT}"/>
						</mx:ArrayCollection>
					</mx:ComboBox>
				</mx:FormItem>	
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date Format:" direction="vertical">
					<mx:TextArea editable="false" borderStyle="none" borderThickness="0" fontSize="10" width="300" 
						text="The date format is specified by a pattern string. Within the pattern, letters are interpreted as the components of the date string. The following pattern letters are supported:"/>
					<mx:DataGrid fontSize="10" rowCount="3">
						<mx:ArrayCollection>
							<mx:Array>
								<mx:Object letter="y" meaning="Year" example="2008; 08"/>
								<mx:Object letter="M" meaning="Month in Year" example="July; Jul; 07"/>
								<mx:Object letter="d" meaning="Day in month" example="10"/>
							</mx:Array>
						</mx:ArrayCollection>
						<mx:columns>											
							<mx:DataGridColumn dataField="letter" width="48" headerText="Letter"/>
							<mx:DataGridColumn dataField="meaning" headerText="Date Component"/>
							<mx:DataGridColumn dataField="example" headerText="Examples"/>
						</mx:columns>
					</mx:DataGrid>
					<mx:TextInput id="dateFormat" text="yyyy-MM-dd"/>
				</mx:FormItem>
			</mx:AddChild>	
		</mx:State>
	</mx:states>
	<mx:Script>
		<![CDATA[
        import com.easyinsight.analysis.conditions.MeasureConditionRange;

        import mx.events.DropdownEvent;

        import com.easyinsight.analysis.options.OptionFactory;

        import mx.collections.ArrayCollection;

        [Bindable]
        private var aggregationTypeObjects:ArrayCollection;
        [Bindable]
        private var dimensionIsDate:Boolean;
        [Bindable]
        private var measureObjects:ArrayCollection;
        private var aggregationTypeMap:Object;
        private var _aggregationType:String = "Sum";
        private var startingAnalysisItem:AnalysisItem;
        private var key:Key;

        [Bindable]
        private var _fieldNameEditable:Boolean = true;

        [Bindable]
        private var dimensionFields:ArrayCollection = new ArrayCollection();

        [Bindable]
        private var useKeyDimensionSelected:Boolean = false;

        [Bindable]
        private var displayName:String;

        [Bindable]
        private var hidden:Boolean;

        public function set fieldNameEditable(fieldNameEditable:Boolean):void {
            _fieldNameEditable = fieldNameEditable;
        }

        public function set analysisItems(analysisItems:ArrayCollection):void {
            for each (var analysisItemWrapper:AnalysisItemWrapper in analysisItems) {
                if (analysisItemWrapper.analysisItem.hasType(AnalysisItemTypes.DIMENSION)) {
                    dimensionFields.addItem(analysisItemWrapper.analysisItem);
                }
            }
        }

        private function onDimensionChange():void {
            var analysisItem:AnalysisItem = dimensionComboBox.selectedItem as AnalysisItem;
            dimensionIsDate = analysisItem is AnalysisDateDimension;
        }

        public function set analysisItem(analysisItem:AnalysisItem):void {
            this.startingAnalysisItem = analysisItem;
            if (aggregationTypeObjects == null) {
                aggregationTypeObjects = getAggregationTypeObjects();
            }
            this.displayName = analysisItem.display;
            this.key = analysisItem.key;
            this.hidden = analysisItem.hidden;
        }

        private function indexOfType(option:String):int {
            if (getGroupingOptions().contains(option)) {
                return 0;
            } else if (getMeasureOptions().contains(option)) {
                return 1;
            } else if (getComplexOptions().contains(option)) {
                return 2;
            }
            return -1;
        }

        override protected function createChildren():void {
            super.createChildren();
            measureObjects = getMeasureOptions();
            if (startingAnalysisItem.hasType(AnalysisItemTypes.CALCULATION)) {
                currentState = "Calculation";
                aggregationChange("Calculation");
            } else {
                var option:String = OptionFactory.getAnalysisItemOption(startingAnalysisItem);
                var index:int = indexOfType(option);
                toggleBar.selectedIndex = index;
                if (index == 0) {
                    aggregationTypeObjects = getGroupingOptions();
                } else if (index == 1) {
                    aggregationTypeObjects = getMeasureOptions();
                } else {
                    aggregationTypeObjects = getComplexOptions();
                }
                aggregationBox.selectedIndex = aggregationTypeObjects.getItemIndex(option);
                aggregationChange(option);
            }
        }

        private function initStuff():void {
            if (aggregationTypeObjects == null) {
                aggregationTypeObjects = getAggregationTypeObjects();
            }
            focusManager.setFocus(fieldNameInput);
            addEventListener(KeyboardEvent.KEY_UP, keyedComplete);
        }

        private function keyedComplete(event:KeyboardEvent):void {
            if (event.keyCode == Keyboard.ENTER) {
                save();
            }
        }

        protected function getAggregationTypeObjects():ArrayCollection {
            return getGroupingOptions();
        }

        protected function getGroupingOptions():ArrayCollection {
            return new ArrayCollection(["Grouping", "Range", "Date", "List"]);
        }

        protected function getMeasureOptions():ArrayCollection {
            return new ArrayCollection(["Sum", "Average", "Min", "Max", "Count"]);
        }

        protected function getComplexOptions():ArrayCollection {
            return new ArrayCollection(["Delta", "Last Value", "Normality"]);
        }

        public function save():AnalysisItem {
            var analysisItem:AnalysisItem;
            switch (currentState) {
                case "Calculation":
                    var analysisCalculation:AnalysisCalculation = startingAnalysisItem as AnalysisCalculation;
                    var calcMeasureConditionRange:MeasureConditionRange = calcMeasureRangeSelection.createMeasureConditionRange();
                    if (calcMeasureConditionRange != null) {
                        analysisCalculation.measureConditionRange = calcMeasureConditionRange;
                    }
                    analysisCalculation.formattingConfiguration = calcFormattingSetup.formattingConfiguration;
                    analysisItem = analysisCalculation;
                    break;
                case "Measure":
                    var analysisMeasure:AnalysisMeasure;
                    switch (aggregationBox.selectedLabel) {
                        case "Sum":
                            analysisMeasure = new AnalysisMeasure(AggregationTypes.SUM);
                            break;
                        case "Average":
                            analysisMeasure = new AnalysisMeasure(AggregationTypes.AVERAGE);
                            break;
                        case "Max":
                            analysisMeasure = new AnalysisMeasure(AggregationTypes.MAX);
                            break;
                        case "Min":
                            analysisMeasure = new AnalysisMeasure(AggregationTypes.MIN);
                            break;
                        case "Count":
                            analysisMeasure = new AnalysisMeasure(AggregationTypes.COUNT);
                            break;
                    }
                    var measureConditionRange:MeasureConditionRange = measureRangeSelection.createMeasureConditionRange();
                    if (measureConditionRange != null) {
                        analysisMeasure.measureConditionRange = measureRangeSelection.createMeasureConditionRange();
                    }
                    analysisMeasure.formattingConfiguration = formattingSetup.formattingConfiguration;
                    analysisItem = analysisMeasure;
                    break;
                case "Grouping":
                    var analysisDimension:AnalysisDimension = new AnalysisDimension();
                    analysisDimension.group = groupCheckbox.selected;
                    if (useKeyDimension.selected) {
                        analysisDimension.keyDimension = dimensionKeyComboBox.selectedItem as AnalysisDimension;
                    }
                    analysisItem = analysisDimension;
                    break;
                case "Range":
                    analysisItem = new AnalysisRangeDimension();
                    break;
                case "List":
                    analysisItem = new AnalysisList(listExpanded.selected);
                    break;
                case "Date":
                    analysisItem = new AnalysisDateDimension(dateBox.selectedItem.data, dateFormat.text);
                    break;
                case "ComplexMeasure":
                    var complexAggregationType:int;
                    switch (complexWrappedAggregations.selectedLabel) {
                        case "Sum":
                            complexAggregationType = AggregationTypes.SUM;
                            break;
                        case "Average":
                            complexAggregationType = AggregationTypes.AVERAGE;
                            break;
                        case "Max":
                            complexAggregationType = AggregationTypes.MAX;
                            break;
                        case "Min":
                            complexAggregationType = AggregationTypes.MIN;
                            break;
                        case "Count":
                            complexAggregationType = AggregationTypes.COUNT;
                            break;
                    }
                    switch (aggregationBox.selectedLabel) {
                        case "Normality":
                            analysisItem = new ComplexAnalysisMeasure(AggregationTypes.NORMALS, complexAggregationType);
                            break;
                    }
                    break;
                case "TemporalMeasure":
                    var temporalAggregationType:int;
                    switch (temporalWrappedAggregations.selectedLabel) {
                        case "Sum":
                            temporalAggregationType = AggregationTypes.SUM;
                            break;
                        case "Average":
                            temporalAggregationType = AggregationTypes.AVERAGE;
                            break;
                        case "Max":
                            temporalAggregationType = AggregationTypes.MAX;
                            break;
                        case "Min":
                            temporalAggregationType = AggregationTypes.MIN;
                            break;
                        case "Count":
                            temporalAggregationType = AggregationTypes.COUNT;
                            break;
                    }
                    switch (aggregationBox.selectedLabel) {
                        case "Delta":
                        case "Last Value":
                            var existingDim:AnalysisDimension = dimensionComboBox.selectedItem as AnalysisDimension;
                            var sortDim:AnalysisDimension;
                            if (dimensionIsDate) {
                                var existingDateDim:AnalysisDateDimension = existingDim as AnalysisDateDimension;
                                var dateDim:AnalysisDateDimension = new AnalysisDateDimension(temporalDateBox.selectedItem.data,
                                        existingDateDim.customDateFormat);
                                dateDim.key = existingDim.key;
                                sortDim = dateDim;
                            } else {
                                sortDim = existingDim;
                            }
                            analysisItem = new TemporalAnalysisMeasure(aggregationBox.selectedLabel == "Delta" ? AggregationTypes.DELTA :
                                    AggregationTypes.LAST_VALUE, temporalAggregationType,
                                    sortDim);
                            break;
                    }
                    break;
            }
            analysisItem.displayName = fieldNameInput.text;
            analysisItem.key = key;
            analysisItem.hidden = hiddenCheckbox.selected;
            //dispatchEvent(new AnalysisItemEditEvent(analysisItem, true));
            return analysisItem;
            //PopUpManager.removePopUp(this);
        }

        protected function getDefaultStart():String {
            return null;
        }


        private function aggregationTypeChanged(event:DropdownEvent):void {
            var newAggregationType:String = event.currentTarget.selectedLabel;
            aggregationChange(newAggregationType);
        }

        private function aggregationChange(newAggregationType:String):void {
            switch (newAggregationType) {
                case "Sum":
                case "Average":
                case "Max":
                case "Min":
                case "Count":
                    currentState = "Measure";
                    if (startingAnalysisItem is AnalysisMeasure) {
                        var analysisMeasure:AnalysisMeasure = startingAnalysisItem as AnalysisMeasure;
                        if (analysisMeasure.measureConditionRange != null) {
                            measureRangeSelection.measureConditionRange = analysisMeasure.measureConditionRange;
                        }
                        if (analysisMeasure.formattingConfiguration != null) {
                            formattingSetup.formattingConfiguration = analysisMeasure.formattingConfiguration;
                        }
                    }
                    break;
                case "Delta":
                case "Last Value":
                    currentState = "TemporalMeasure";
                    if (startingAnalysisItem is TemporalAnalysisMeasure) {
                        var temporalAnalysisMeasure:TemporalAnalysisMeasure = startingAnalysisItem as TemporalAnalysisMeasure;
                        if (temporalAnalysisMeasure.wrappedAggregation > 0) {
                            temporalWrappedAggregations.selectedIndex = temporalAnalysisMeasure.wrappedAggregation - 1;
                        }
                    }
                    break;
                case "Normality":
                    currentState = "ComplexMeasure";
                    if (startingAnalysisItem is ComplexAnalysisMeasure) {
                        var complexAnalysisMeasure:ComplexAnalysisMeasure = startingAnalysisItem as ComplexAnalysisMeasure;
                        if (complexAnalysisMeasure.wrappedAggregation > 0) {
                            complexWrappedAggregations.selectedIndex = complexAnalysisMeasure.wrappedAggregation - 1;
                        }
                    }
                    break;
                case "Calculation":
                    currentState = "Calculation";
                    if (startingAnalysisItem is AnalysisCalculation) {
                        var analysisCalculation:AnalysisCalculation = startingAnalysisItem as AnalysisCalculation;
                        if (analysisCalculation.measureConditionRange != null) {
                            calcMeasureRangeSelection.measureConditionRange = analysisCalculation.measureConditionRange;
                        }
                        if (analysisCalculation.formattingConfiguration != null) {
                            calcFormattingSetup.formattingConfiguration = analysisCalculation.formattingConfiguration;
                        }
                    }
                    break;
                case "Grouping":
                    currentState = "Grouping";
                    if (startingAnalysisItem is AnalysisDimension) {
                        var analysisDimension:AnalysisDimension = startingAnalysisItem as AnalysisDimension;
                        groupCheckbox.selected = analysisDimension.group;
                        useKeyDimensionSelected = analysisDimension.keyDimension != null;
                        dimensionKeyComboBox.selectedItem = analysisDimension.keyDimension;
                    }
                    break;
                case "Range":
                    currentState = "Range";
                    break;
                case "List":
                    currentState = "List";
                    break;
                case "Date":
                    currentState = "Date";
                    if (startingAnalysisItem is AnalysisDateDimension) {
                        var analysisDateDimension:AnalysisDateDimension = startingAnalysisItem as AnalysisDateDimension;
                        switch (analysisDateDimension.dateLevel) {
                            case AnalysisItemTypes.YEAR_LEVEL:
                                dateBox.selectedIndex = 0;
                                break;
                            case AnalysisItemTypes.MONTH_LEVEL:
                                dateBox.selectedIndex = 1;
                                break;
                            case AnalysisItemTypes.DAY_LEVEL:
                                dateBox.selectedIndex = 2;
                                break;
                        }
                        dateFormat.text = analysisDateDimension.customDateFormat;
                    } else {
                        dateBox.selectedIndex = 0;
                    }
                    break;
            }
        }

        private function toggleClick():void {
            if (toggleBar.selectedIndex == 0) {
                aggregationTypeObjects = getGroupingOptions();
            } else if (toggleBar.selectedIndex == 1) {
                aggregationTypeObjects = getMeasureOptions();
            } else {
                aggregationTypeObjects = getComplexOptions();
            }
            aggregationChange(aggregationTypeObjects.getItemAt(0) as String);
        }
        ]]>
	</mx:Script>
	<mx:VBox>
		<mx:ToggleButtonBar id="toggleBar" itemClick="toggleClick()">
			<mx:dataProvider>
                <mx:Array>
                    <mx:String>Grouping</mx:String>
                    <mx:String>Number</mx:String>
                    <mx:String>Complex</mx:String>                    
                </mx:Array>
            </mx:dataProvider>
		</mx:ToggleButtonBar>	
	</mx:VBox>
	<mx:Form id="coreForm">
		<mx:FormItem label="Field Name: " direction="horizontal" id="fieldNameText">
			<mx:TextInput id="fieldNameInput" text="{displayName}" editable="{_fieldNameEditable}"/>
		</mx:FormItem>
        <mx:FormItem label="Hidden: " direction="horizontal" id="hiddenText">
            <mx:CheckBox id="hiddenCheckbox" selected="{hidden}"/>
        </mx:FormItem>
		<mx:FormItem label="Field Type: " direction="horizontal" id="firstForm">
			<mx:ComboBox id="aggregationBox" dataProvider="{aggregationTypeObjects}" 
				close="aggregationTypeChanged(event)" rowCount="9"/>
		</mx:FormItem>						
	</mx:Form>
	<mx:StringValidator id="nameValidator" source="{fieldNameInput}" property="text" minLength="3"/>
</mx:Box>
