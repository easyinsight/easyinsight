<?xml version="1.0" ?>
<analysis:AnalysisItemDetailEditor xmlns:mx="http://www.adobe.com/2006/mxml"
                                   xmlns:analysis="com.easyinsight.analysis.*"
                                   xmlns:formatter="com.easyinsight.analysis.formatter.*"
                                   xmlns:util="com.easyinsight.util.*">
    <mx:Script><![CDATA[

        import mx.collections.ArrayCollection;
        import mx.controls.Alert;


        [Bindable]
        private var formattingConfiguration:int;

        override public function createAnalysisItem(aggregation:String):AnalysisItem {
            var analysisMeasure:AnalysisMeasure;
            switch (aggregation) {
                case "Sum":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.SUM);
                    break;
                case "Average":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.AVERAGE);
                    break;
                case "Max":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.MAX);
                    break;
                case "Min":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.MIN);
                    break;
                case "Count":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.COUNT);
                    break;
                case "Median":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.MEDIAN);
                    break;
                case "Variance":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.VARIANCE);
                    break;
                case "Ranking":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.RANK);
                    break;
                case "Percent of Total":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.PERCENT_OF_TOTAL);
                    break;
                case "Count Distinct":
                    analysisMeasure = new AnalysisMeasure(AggregationTypes.COUNT_DISTINCT);
                    break;
            }
            return analysisMeasure;
        }

        [Bindable]
        private var underline:Boolean;

        [Bindable]
        private var precision:int;

        [Bindable]
        private var minPrecision:int;

        override public function save(analysisItem:AnalysisItem, aggregation:String = null):void {
            var analysisMeasure:AnalysisMeasure = analysisItem as AnalysisMeasure;
            switch (aggregation) {
                case "Sum":
                    analysisMeasure.aggregation = AggregationTypes.SUM;
                    break;
                case "Average":
                    analysisMeasure.aggregation = AggregationTypes.AVERAGE;
                    break;
                case "Max":
                    analysisMeasure.aggregation = AggregationTypes.MAX;
                    break;
                case "Min":
                    analysisMeasure.aggregation = AggregationTypes.MIN;
                    break;
                case "Count":
                    analysisMeasure.aggregation = AggregationTypes.COUNT;
                    break;
                case "Median":
                    analysisMeasure.aggregation = AggregationTypes.MEDIAN;
                    break;
                case "Variance":
                    analysisMeasure.aggregation = AggregationTypes.VARIANCE;
                    break;
                case "Ranking":
                    analysisMeasure.aggregation = AggregationTypes.RANK;
                    break;
                case "Percent of Total":
                    analysisMeasure.aggregation = AggregationTypes.PERCENT_OF_TOTAL;
                    break;
                case "Count Distinct":
                    analysisMeasure.aggregation = AggregationTypes.COUNT_DISTINCT;
                    break;
            }
            analysisMeasure.formattingType = formattingSetup.formattingConfiguration;
            analysisMeasure.precision = precisionInput.value;
            analysisMeasure.underline = underlineCheckbox.selected;
            analysisMeasure.minPrecision = minPrecisionInput.value;
            if (dateComparisonBox.selectedItem is AnalysisItem) {
                analysisMeasure.defaultDate = dateComparisonBox.selectedItem.display;
            }

            var currencyField:AnalysisItem = currencyBox.selectedItem as AnalysisItem;
            if (currencyField != null) {
                analysisMeasure.currencyField = currencyField;
            }
        }

        override protected function commitProperties():void {
            super.commitProperties();
            var fieldArray:Array = [];
            var noComp:Object = { display: "[ No Currency ]"};
            fieldArray.push(noComp);
            for each (var g:AnalysisItem in dimensionFields) {
                fieldArray.push(g);
            }
            var noDate:Object = { display: "[ No Date ]"};
            var dateArray:Array = [ noDate ];
            for each (var d:AnalysisItem in dateDimensionFields) {
                dateArray.push(d);
            }
            currencyBox.dataProvider = new ArrayCollection(fieldArray);
            dateComparisonBox.dataProvider = new ArrayCollection(dateArray);
            if (analysisMeasure != null) {
                currencyBox.selectedValue = analysisMeasure.currencyField != null ? analysisMeasure.currencyField.display : null;
            }
            if (analysisMeasure != null) {
                dateComparisonBox.selectedValue = analysisMeasure.defaultDate;
            }
        }

        public var analysisMeasure:AnalysisMeasure;

        [Bindable]
        private var fields:ArrayCollection;

        [Bindable]
        private var sortDimension:String;

        override public function set analysisItem(val:AnalysisItem):void {
            super.analysisItem = val;
            if (val is AnalysisMeasure) {
                var analysisMeasure:AnalysisMeasure = val as AnalysisMeasure;
                this.analysisMeasure = analysisMeasure;
                formattingConfiguration = analysisMeasure.formattingType;
                precision = analysisMeasure.precision;
                minPrecision = analysisMeasure.minPrecision;
                underline = analysisMeasure.underline;
            }
        }
        ]]></mx:Script>
    <mx:FormItem label="Formatting: ">
        <formatter:FormattingSetup id="formattingSetup" formattingConfiguration="{formattingConfiguration}"/>
    </mx:FormItem>
    <mx:FormItem label="Underline:">
        <mx:CheckBox id="underlineCheckbox" selected="{underline}"/>
    </mx:FormItem>
    <mx:FormItem label="Floating Point Precision:">
        <mx:NumericStepper id="precisionInput" value="{precision}" minimum="0" maximum="50"/>
    </mx:FormItem>
    <mx:FormItem label="Minimum Precision:">
        <mx:NumericStepper id="minPrecisionInput" value="{minPrecision}" minimum="0" maximum="50"/>
    </mx:FormItem>
    <mx:FormItem label="Currency:">
        <util:SmartComboBox id="currencyBox" labelField="display"
                            selectedProperty="display"/>
    </mx:FormItem>
    <mx:FormItem label="Date Comparison:">
        <util:SmartComboBox id="dateComparisonBox" labelField="display"
                            selectedProperty="display"/>
    </mx:FormItem>
</analysis:AnalysisItemDetailEditor>